runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
library(NLMR)
library(landscapetools)
library(ggplot2)
library(raster)
library(caret)
library(Metrics)
################################################################################
# b)
#?nlm_distancegradient
# simulate a distance gradient
distance_gradient <- nlm_distancegradient(ncol = 100, nrow = 100,
origin = c(80, 10, 40, 5))
################################################################################
# c)
# simulate random curdling
edge_gradient <- nlm_edgegradient(ncol = 100, nrow = 100, direction = 30)
################################################################################
# d)
# simulate fractional brownian motion
#?nlm_fbm
set.seed(100)
fbm_raster  <- nlm_fbm(ncol = 100, nrow = 100, fract_dim = 0.2)
################################################################################
# e)
# simulate random gaussian field
#?nlm_gaussianfield
set.seed(100)
gaussian_field <- nlm_gaussianfield(ncol = 100, nrow = 100,
autocorr_range = 100,
mag_var = 8,
nug = 5)
################################################################################
# g)
# simulate neighborhood model
set.seed(100)
neigh_raster <- nlm_neigh(ncol = 100, nrow = 100, p_neigh = 0.75, p_empty = 0.1,
categories = 5, neighbourhood = 8)
################################################################################
# h)
# simulate percolation model
set.seed(100)
percolation <- nlm_percolation(ncol = 100, nrow = 100, prob = 0.5)
# visualize the NLM
# landscapetools::show_landscape(percolation)
# plot(percolation)
################################################################################
# i)
# simulate planar gradient
set.seed(100)
planar_gradient <- nlm_planargradient(ncol = 100, nrow = 100)
################################################################################
# k)
# simulate polygonal landscapes
set.seed(100)
mosaictess <- nlm_mosaictess(ncol = 100, nrow = 100, germs = 50)
################################################################################
# l)
# simulate spatially random model
set.seed(100)
random <- nlm_random(ncol = 100, nrow = 100)
################################################################################
# m)
# simulate random clustering
set.seed(100)
random_cluster <- nlm_randomcluster(ncol = 100, nrow = 100,
p = 0.4,
ai = c(0.25, 0.25, 0.5))
# midpoint_displacement <- nlm_mpd(ncol = 102,
#                                  nrow = 102,
#                                  roughness = 0.7)
#
# # visualize the NLM
# landscapetools::show_landscape(midpoint_displacement)
# midpoint_displacement
################################################################################
# o)
# simulate random rectangular cluster
set.seed(100)
randomrectangular_cluster <- nlm_randomrectangularcluster(ncol = 100,
nrow = 100,
minl = 5,
maxl = 10)
################################################################################
# create predictor stack
# Create grids
dimgrid <- 100
rast_grid <- raster(ncols=dimgrid, nrows=dimgrid, xmn=0, xmx=dimgrid, ymn=0, ymx=dimgrid)
point_grid <- st_as_sf(rasterToPoints(rast_grid, spatial = TRUE))
# Create study area
study_area <- st_as_sf(as(extent(rast_grid), "SpatialPolygons"))
# Defining stack of predictors
predictors <- stack(distance_gradient, edge_gradient, fbm_raster,
gaussian_field, mosaictess, neigh_raster,
planar_gradient, random, random_cluster,
randomrectangular_cluster)
# Changing the name of the predictors
names(predictors) <- c("pred_1", "pred_2", "pred_3",
"pred_4", "pred_5", "pred_6",
"pred_7", "pred_8", "pred_9",
"pred_10")
show_landscape(predictors)
predictors[,1]
predictors[,1:2]
predictors[,"pred_1"]
predictors
predictors(pred_1)
predictors[pred_1]
predictors["pred_1"]
head(predictors)
pred <- names(predictors)
pred
head(predictors[,pred])
predictors[,pred]
train_data <- as.data.frame(raster::extract(predictors(), train_points()))
# Training points: Clust1
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
train_points <- st_sf(geom=train_clust1)
ggplot() +
geom_sf(data = train_points, size = 1) +
geom_sf(data = study_area,  alpha = 0) +
theme_bw()
#' Sandbox clustered sampling
#' @description
#' Function to generate clustered samples by randomly simulating parent points and subsequently
#' random offspring points located within a radius of the parents.
#' @param area A sf polygon object representing the study area boundaries.
#' @param n1 Integer. Number of parents to simulate.
#' @param n2 Integer. Number of offspring to simulate.
#' @param radius Numeric. Radius of the buffer for offspring simulation.
#' @return A sf point object with the samples.
clustered_sample <- function(area, n1, n2, radius){
# Calculate number of offspring per parent and round in case not integers are given
nchild <- round(n2/n1, 0)
n2 <- round(n2, 0)
n1 <- round(n1, 0)
# Simulate parents
parents <- st_sf(geom=st_sample(area, n1, type="random"))
res <- parents
# Simulate offspring
for(i in 1:nrow(parents)){
# Generate buffer and cut parts outside of the area of study
buf <- st_buffer(parents[i,], dist=radius)
buf <- st_crop(buf, st_bbox(area))
# Simulate children
children <- st_sf(geom=st_sample(buf, nchild, type="random"))
res <- rbind(res, children)
}
return(res)
}
#' Create a square polygon
#' @param xmin Numeric. Minimum x coordinate for square creation.
#' @param ymin Numeric. Minimum y coordinate for square creation.
#' @param ch_len Numeric. Side length of the square
#' @return A sf polygon object corresponding to a square.
#' @examples
#' plot(checkerpolys(0, 0, 10))
checkerpolys <- function(xmin, ymin, ch_len){
# Get maxs
xmax <- xmin + ch_len
ymax <- ymin + ch_len
# Create poly
poly <- list(matrix(c(xmin,ymin,
xmax,ymin,
xmax,ymax,
xmin,ymax,
xmin,ymin),ncol=2, byrow=TRUE))
poly <- st_sf(geom=st_sfc(st_polygon(poly)))
return(poly)
}
#' @description
#' This functions partitions the study area into many squares, and randomly selects a subset of
#' them for non-uniform sampling.
#' @param dgrid Integer. Dimension of one side of the squared study area.
#' @param blockside Integer. Number of squares per axis.
#' @param targetblock Integer. Number of squares from which we will sample.
#' @return A polygon sf object consisting of squares with a column named "sample" taking two
#' values: "Yes", if the square is considered for sampling; "No", otherwise.
#' @examples
#' plot(nonuniform_sampling_polys(100))
nonuniform_sampling_polys <- function(dgrid, blockside=5, targetblock=5){
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
}
# Draw random blocks for sampling
sampling_vector <- c(rep("Yes", targetblock), rep("No", blockside^2-targetblock))
checker_folds$sample <- sample(sampling_vector, replace=FALSE)
# Return object
return(checker_folds)
}
train_points <- st_sample(study_area, 50, type = "random")
library(sf)
# Training points: Clust1
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
train_points <- st_sf(geom=train_clust1)
n_train <- 50
# Training points: Clust1
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
train_points <- st_sf(geom=train_clust1)
ggplot() +
geom_sf(data = train_points, size = 1) +
geom_sf(data = study_area,  alpha = 0) +
theme_bw()
# Training points: Clust1
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
################################################################################
# create predictor stack
# Create grids
dimgrid <- 100
rast_grid <- raster(ncols=dimgrid, nrows=dimgrid, xmn=0, xmx=dimgrid, ymn=0, ymx=dimgrid)
point_grid <- st_as_sf(rasterToPoints(rast_grid, spatial = TRUE))
n_train <- 50
# Create study area
study_area <- st_as_sf(as(extent(rast_grid), "SpatialPolygons"))
# Defining stack of predictors
predictors <- stack(distance_gradient, edge_gradient, fbm_raster,
gaussian_field, mosaictess, neigh_raster,
planar_gradient, random, random_cluster,
randomrectangular_cluster)
# Changing the name of the predictors
names(predictors) <- c("pred_1", "pred_2", "pred_3",
"pred_4", "pred_5", "pred_6",
"pred_7", "pred_8", "pred_9",
"pred_10")
show_landscape(predictors)
# Training points: Clust1
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
train_points <- st_sf(geom=train_clust1)
train_points <- st_sf(geom=train_points)
ggplot() +
geom_sf(data = train_points, size = 1) +
geom_sf(data = study_area,  alpha = 0) +
theme_bw()
train_data <- as.data.frame(raster::extract(predictors, train_points))
head(train_data)
pred <- names(predictors)
train_data[,pred]
pred <- names("pred_3", "pred_5")
train_data[,pred]
pred <- names(c("pred_3", "pred_5"))
train_data[,pred]
pred <- names(c("pred_3", "pred_5"))
train_data[,pred]
pred <- names(c("pred_1", "pred_2"))
train_data[,pred]
train_data <- as.data.frame(raster::extract(predictors, train_points))
head(train_data)
pred <- names(c("pred_1", "pred_2"))
train_data[,pred]
library(shiny); runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
View(train_data)
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
library(shiny); runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
ui <- navbarPage(title = "Remote Sensing Modeling Tool", theme = shinytheme("flatly"),
tabPanel("App",
sidebarLayout(
sidebarPanel(
h4("Parameters for predictors"),
# sliderInput(
#   inputId = "n_predictors",
#   label = "Number of predictors:",
#   value = 11,
#   min = 2,
#   max = 20,
#   step = 1,
#   width = "100%"
# ),
selectInput(
inputId = "nlm", label = "NLM:",
choices = c("Distance gradient", "Edge gradient", "Fractional brownian motion",
"Gaussian random field", "Planar gradient", "Polygonal landscapes",
"Random", "Random cluster", "Random neighbourhood", "Random rectangular cluster"),
multiple = TRUE
),
actionButton(
inputId = "generate_predictors", label = "Generate selected predictors"
),
p(),
actionButton(
inputId = "sim_outcome", label = "Simulate outcome"
),
h4("Parameters for training data"),
numericInput(
inputId = "n_trainingdata",
label = "Number of sampling points:",
value = 50,
min = 50,
max = 250,
step = 50,
width = "60%"
),
selectInput(
inputId = "dist_trainingdata", label = "Distribution of sampling points:",
choices = c("Random" = "random",
"Regular" = "regular",
"Weak clustering" ="clust1",
"Strong clustering" ="clust2",
"Non-uniform" ="nonunif"),
selected = "Random"
),
h4("Modelling"),
radioButtons(
inputId = "algorithm", label = "Choose algorithm for training:",
choices = c("Random Forest", "Support Vector Machines"),
selected = "Random Forest"
),
selectInput(
inputId = "cv_method", label = "Cross-validation method:",
choices = c("Random", "Spatial"),
selected = "Spatial"
),
selectInput(
inputId = "variableSelection", label = "Variable Selection:",
choices = c("None", "FFS", "RFE"),
selected = "None"
),
actionButton(
inputId = "gen_prediction", label = "Generate prediction"
),
),
mainPanel(
h4("Predictors and sampling points"),
wellPanel(
fluidRow(title = "Predictors and training data",
column(6, plotOutput(outputId = "predictors")),
column(6, plotOutput(outputId = "trainingdata"))
)
),
wellPanel(
fluidRow(title = " and training data",
column(6, plotOutput(outputId = "predictors")),
column(6, plotOutput(outputId = "trainingdata"))
)
),
wellPanel(
fluidRow(
column(6, plotOutput(outputId = "outcome")),
column(6, plotOutput(outputId = "prediction"))
)
),
wellPanel(
fluidRow(
column(6, plotOutput(outputId = "difference")),
column(6, textOutput(outputId = "mae")),
)
),
wellPanel(
fluidRow(
column(6, plotOutput(outputId = "aoa")),
column(6, plotOutput(outputId = "di")),
)
),
br()
)
)
),
tabPanel("Documentation"),
tabPanel("Demo"),
)
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
library(shiny); runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files/Test_shiny.R')
shiny::runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
shiny::runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
# Set working directory
getwd()
setwd("./Sentinel-2 Bänder")
setwd("C:/Users/thali/Documents/WWU/7. Semester/Fernerkundung VL + Ü/Daten für R/Köln 2")
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
runApp('C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files')
setwd("C:/Users/thali/Documents/GitHub/remote-sensing-modeling-tool/R files")
runApp()
runApp()
shiny::runApp()
?theme_bw
runApp()
?geom_raster
runApp()
?distance_gradient
?nlm_distancegradient
runApp()
?nlm_gaussianfield
runApp()
library("devtools")
devtools::install_github("carlesmila/NNDM")
library(devtools)
library(devtools)
devtools::install_github("carlesmila/NNDM")
library(devtools)
library(devtools)
devtools::install_github("carlesmila/NNDM")
?variogram
?variogram()
shiny::runApp()
runApp()
runApp()
runApp()
# NOT RUN {
library(sp)
data(meuse)
# no trend:
coordinates(meuse) = ~x+y
variogram(log(zinc)~1, meuse)
data(meuse)
View(meuse)
runApp()
runApp()
runApp()
runApp()
library(devtools) # oder remotes
install_github("HannaMeyer/CAST")
install_github("carlesmila/NNDM")
install_github("carlesmila/NNDM", force = TRUE)
?plot_geodist
shiny::runApp()
runApp()
runApp()
runApp()
library(shiny)
library(ggplot2)
library(dplyr)
library(NLMR)
library(landscapetools)
library(raster)
library(caret)
library(CAST)
library(sf)
library(shinythemes)
library(gstat)
library(NNDM)
runApp()
runApp()
install.packages("dplyr")
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
