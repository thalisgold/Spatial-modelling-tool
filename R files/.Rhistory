study_area <- st_as_sf(as(extent(rast_grid), "SpatialPolygons"))
# Variogram model
variog_mod <- vgm(model = "Sph", psill = 1, range = range, nugget = 0)
gstat_mod <- gstat(formula = z~1, dummy = TRUE, beta = 0, model = variog_mod, nmax = 100)
# Generate 20 fields with that model
cov_points <- predict(gstat_mod, point_grid, nsim = 20)
# Create stack of predictors and visualize it
cov_stack <- rasterise_and_stack(cov_points, 1:20, paste0("cov", 1:20))
# True outcome using van der Laan's formula
out_true <- cov_stack$cov1*cov_stack$cov2 + cov_stack$cov10^2 -
cov_stack$cov3*cov_stack$cov17 - cov_stack$cov15*cov_stack$cov4 +
cov_stack$cov9*cov_stack$cov5 + cov_stack$cov19 -
cov_stack$cov20^2 + cov_stack$cov9*cov_stack$cov8
# Random noise
rnoise <- raster(ncols=dimgrid, nrows=dimgrid, xmn=0, xmx=dimgrid, ymn=0, ymx=dimgrid)
vals <- rnorm(dimgrid*dimgrid, sd=1)
rnoise <- setValues(rnoise, vals)
# Spatially correlated noise
snoise <- predict(gstat_mod, point_grid, nsim = 1)
snoise <- rasterFromXYZ(cbind(st_coordinates(snoise),
as.matrix(as.data.frame(snoise)[,1], ncol=1)))
# Add noise variables
outcome <- out_true + rnoise + snoise
names(outcome) <- "outcome"
# Training points
if(dist_it %in% c("clust1")){
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
}else if(dist_it %in% c("clust2")){
train_points <- clustered_sample(study_area, n_train/10, n_train*9/10, dimgrid*0.05)
}else if(dist_it %in% c("nonunif")){
nonuniform_areas <- nonuniform_sampling_polys(dgrid=dimgrid)
train_points <- st_sample(filter(nonuniform_areas, sample=="Yes"), n_train, type = "random")
train_points <- st_sf(geom=train_points)
}else{
train_points <- st_sample(study_area, n_train, type = dist_it)
train_points <- st_sf(geom=train_points)
}
ggplot() +
geom_sf(data = train_points, size = 1) +
geom_sf(data = study_area,  alpha = 0) +
theme_bw()
?trainControl
runApp('Test_shiny.R')
runApp('Test_shiny.R')
install.packages("blockCV")
library(blockCV)
# Create grids
dimgrid <- 100
rast_grid <- raster(ncols=dimgrid, nrows=dimgrid, xmn=0, xmx=dimgrid, ymn=0, ymx=dimgrid)
point_grid <- st_as_sf(rasterToPoints(rast_grid, spatial = TRUE))
n_train <- 50
# Create study area
study_area <- st_as_sf(as(extent(rast_grid), "SpatialPolygons"))
# Training points: Clust1
train_points <- clustered_sample(study_area, n_train/5, n_train*4/5, dimgrid*0.05)
#' Sandbox clustered sampling
#' @description
#' Function to generate clustered samples by randomly simulating parent points and subsequently
#' random offspring points located within a radius of the parents.
#' @param area A sf polygon object representing the study area boundaries.
#' @param n1 Integer. Number of parents to simulate.
#' @param n2 Integer. Number of offspring to simulate.
#' @param radius Numeric. Radius of the buffer for offspring simulation.
#' @return A sf point object with the samples.
clustered_sample <- function(area, n1, n2, radius){
# Calculate number of offspring per parent and round in case not integers are given
nchild <- round(n2/n1, 0)
n2 <- round(n2, 0)
n1 <- round(n1, 0)
# Simulate parents
parents <- st_sf(geom=st_sample(area, n1, type="random"))
res <- parents
# Simulate offspring
for(i in 1:nrow(parents)){
# Generate buffer and cut parts outside of the area of study
buf <- st_buffer(parents[i,], dist=radius)
buf <- st_crop(buf, st_bbox(area))
# Simulate children
children <- st_sf(geom=st_sample(buf, nchild, type="random"))
res <- rbind(res, children)
}
return(res)
}
train_points <- st_sample(study_area, 50, type = "random")
train_points <- st_sf(geom=train_points)
train_points
sb <- spatialBlock(train_points,
"Sample points",
rast_grid,
k = 25)
blockside = 5
targetblock = 5
# Calculate right margin and size of the block
size_block <- dgrid/blockside
dgrid = 100
blockside = 5
targetblock = 5
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
#' Create a square polygon
#' @param xmin Numeric. Minimum x coordinate for square creation.
#' @param ymin Numeric. Minimum y coordinate for square creation.
#' @param ch_len Numeric. Side length of the square
#' @return A sf polygon object corresponding to a square.
#' @examples
#' plot(checkerpolys(0, 0, 10))
checkerpolys <- function(xmin, ymin, ch_len){
# Get maxs
xmax <- xmin + ch_len
ymax <- ymin + ch_len
# Create poly
poly <- list(matrix(c(xmin,ymin,
xmax,ymin,
xmax,ymax,
xmin,ymax,
xmin,ymin),ncol=2, byrow=TRUE))
poly <- st_sf(geom=st_sfc(st_polygon(poly)))
return(poly)
}
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
checker_folds
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
}
checker_folds
plot(checker_folds)
View(checker_folds)
spatial_blocks <- nonuniform_sampling_polys(100)
#' @description
#' This functions partitions the study area into many squares, and randomly selects a subset of
#' them for non-uniform sampling.
#' @param dgrid Integer. Dimension of one side of the squared study area.
#' @param blockside Integer. Number of squares per axis.
#' @param targetblock Integer. Number of squares from which we will sample.
#' @return A polygon sf object consisting of squares with a column named "sample" taking two
#' values: "Yes", if the square is considered for sampling; "No", otherwise.
#' @examples
#' plot(nonuniform_sampling_polys(100))
nonuniform_sampling_polys <- function(dgrid, blockside=5, targetblock=5){
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
}
# Draw random blocks for sampling
sampling_vector <- c(rep("Yes", targetblock), rep("No", blockside^2-targetblock))
checker_folds$sample <- sample(sampling_vector, replace=FALSE)
# Return object
return(checker_folds)
}
spatial_blocks <- nonuniform_sampling_polys(100)
plot(spatial_blocks)
View(spatial_blocks)
spatial_blocks <- nonuniform_sampling_polys(100)
plot(spatial_blocks)
#' @description
#' This functions partitions the study area into many squares, and randomly selects a subset of
#' them for non-uniform sampling.
#' @param dgrid Integer. Dimension of one side of the squared study area.
#' @param blockside Integer. Number of squares per axis.
#' @param targetblock Integer. Number of squares from which we will sample.
#' @return A polygon sf object consisting of squares with a column named "sample" taking two
#' values: "Yes", if the square is considered for sampling; "No", otherwise.
#' @examples
#' plot(nonuniform_sampling_polys(100))
nonuniform_sampling_polys <- function(dgrid, blockside=5, targetblock=5){
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
checker_folds$ID <- i
}
# Draw random blocks for sampling
# sampling_vector <- c(rep("Yes", targetblock), rep("No", blockside^2-targetblock))
# checker_folds$sample <- sample(sampling_vector, replace=FALSE)
# Return object
return(checker_folds)
}
spatial_blocks <- nonuniform_sampling_polys(100)
plot(spatial_blocks)
spatial_blocks <- nonuniform_sampling_polys(100)
#' @description
#' This functions partitions the study area into many squares, and randomly selects a subset of
#' them for non-uniform sampling.
#' @param dgrid Integer. Dimension of one side of the squared study area.
#' @param blockside Integer. Number of squares per axis.
#' @param targetblock Integer. Number of squares from which we will sample.
#' @return A polygon sf object consisting of squares with a column named "sample" taking two
#' values: "Yes", if the square is considered for sampling; "No", otherwise.
#' @examples
#' plot(nonuniform_sampling_polys(100))
nonuniform_sampling_polys <- function(dgrid, blockside=5, targetblock=5){
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
# checker_folds$ID <- i
}
# Draw random blocks for sampling
# sampling_vector <- c(rep("Yes", targetblock), rep("No", blockside^2-targetblock))
# checker_folds$sample <- sample(sampling_vector, replace=FALSE)
# Return object
return(checker_folds)
}
spatial_blocks <- nonuniform_sampling_polys(100)
plot(spatial_blocks)
#' @description
#' This functions partitions the study area into many squares, and randomly selects a subset of
#' them for non-uniform sampling.
#' @param dgrid Integer. Dimension of one side of the squared study area.
#' @param blockside Integer. Number of squares per axis.
#' @param targetblock Integer. Number of squares from which we will sample.
#' @return A polygon sf object consisting of squares with a column named "sample" taking two
#' values: "Yes", if the square is considered for sampling; "No", otherwise.
#' @examples
#' plot(nonuniform_sampling_polys(100))
nonuniform_sampling_polys <- function(dgrid, blockside=5, targetblock=5){
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
# checker_folds$ID <- i
}
checker_folds$ID <- c(1:25)
# Draw random blocks for sampling
# sampling_vector <- c(rep("Yes", targetblock), rep("No", blockside^2-targetblock))
# checker_folds$sample <- sample(sampling_vector, replace=FALSE)
# Return object
return(checker_folds)
}
spatial_blocks <- nonuniform_sampling_polys(100)
plot(spatial_blocks)
View(spatial_blocks)
?CreateSpacetimeFolds
runApp('Test_shiny.R')
spatial_blocks
trainingsdaten_koeln <- readRDS("C:/Users/thali/Downloads/trainingsdaten_koeln.RDS")
View(trainingsdaten_koeln)
runApp('Test_shiny.R')
runApp('Test_shiny.R')
sampling_points <- generate_sampling_points(input$n_sampling_points, input$dist_sampling_points)
#' Sandbox clustered sampling
#' @description
#' Function to generate clustered samples by randomly simulating parent points and subsequently
#' random offspring points located within a radius of the parents.
#' @param area A sf polygon object representing the study area boundaries.
#' @param n1 Integer. Number of parents to simulate.
#' @param n2 Integer. Number of offspring to simulate.
#' @param radius Numeric. Radius of the buffer for offspring simulation.
#' @return A sf point object with the samples.
clustered_sample <- function(area, n1, n2, radius){
# Calculate number of offspring per parent and round in case not integers are given
nchild <- round(n2/n1, 0)
n2 <- round(n2, 0)
n1 <- round(n1, 0)
# Simulate parents
parents <- st_sf(geom=st_sample(area, n1, type="random"))
res <- parents
# Simulate offspring
for(i in 1:nrow(parents)){
# Generate buffer and cut parts outside of the area of study
buf <- st_buffer(parents[i,], dist=radius)
buf <- st_crop(buf, st_bbox(area))
# Simulate children
children <- st_sf(geom=st_sample(buf, nchild, type="random"))
res <- rbind(res, children)
}
return(res)
}
#' Create a square polygon
#' @param xmin Numeric. Minimum x coordinate for square creation.
#' @param ymin Numeric. Minimum y coordinate for square creation.
#' @param ch_len Numeric. Side length of the square
#' @return A sf polygon object corresponding to a square.
#' @examples
#' plot(checkerpolys(0, 0, 10))
checkerpolys <- function(xmin, ymin, ch_len){
# Get maxs
xmax <- xmin + ch_len
ymax <- ymin + ch_len
# Create poly
poly <- list(matrix(c(xmin,ymin,
xmax,ymin,
xmax,ymax,
xmin,ymax,
xmin,ymin),ncol=2, byrow=TRUE))
poly <- st_sf(geom=st_sfc(st_polygon(poly)))
return(poly)
}
#' @description
#' This functions partitions the study area into many squares, and randomly selects a subset of
#' them for non-uniform sampling.
#' @param dgrid Integer. Dimension of one side of the squared study area.
#' @param blockside Integer. Number of squares per axis.
#' @param targetblock Integer. Number of squares from which we will sample.
#' @return A polygon sf object consisting of squares with a column named "sample" taking two
#' values: "Yes", if the square is considered for sampling; "No", otherwise.
#' @examples
#' plot(nonuniform_sampling_polys(100))
nonuniform_sampling_polys <- function(dgrid, blockside=5, targetblock=5){
# Calculate right margin and size of the block
size_block <- dgrid/blockside
# Construct grid
xmins <- seq(0, dgrid-size_block, size_block)
ymins <- xmins
coords_checker <- expand.grid(xmins=xmins, ymins=ymins)
# Create 1st square poly
checker_folds <- checkerpolys(coords_checker$xmins[1], coords_checker$ymins[1], size_block)
# Iterate for the rest and add
for(i in 2:nrow(coords_checker)){
temp <- checkerpolys(coords_checker$xmins[i],
coords_checker$ymins[i], size_block)
checker_folds <- rbind(checker_folds,temp)
}
# Draw random blocks for sampling
sampling_vector <- c(rep("Yes", targetblock), rep("No", blockside^2-targetblock))
checker_folds$sample <- sample(sampling_vector, replace=FALSE)
# Return object
return(checker_folds)
}
train_points <- st_sample(study_area, 50, type = "random")
# Create study area
study_area <- st_as_sf(as(extent(rast_grid), "SpatialPolygons"))
# Create grids
dimgrid <- 100
rast_grid <- raster(ncols=dimgrid, nrows=dimgrid, xmn=0, xmx=dimgrid, ymn=0, ymx=dimgrid)
point_grid <- st_as_sf(rasterToPoints(rast_grid, spatial = TRUE))
n_train <- 50
# Create study area
study_area <- st_as_sf(as(extent(rast_grid), "SpatialPolygons"))
train_points <- st_sample(study_area, 50, type = "random")
train_points <- st_sf(geom=train_points)
train_points
################################################################################
# b)
#?nlm_distancegradient
# simulate a distance gradient
distance_gradient <- nlm_distancegradient(ncol = 100, nrow = 100,
origin = c(80, 10, 40, 5))
################################################################################
# c)
# simulate random curdling
edge_gradient <- nlm_edgegradient(ncol = 100, nrow = 100, direction = 30)
################################################################################
# d)
# simulate fractional brownian motion
#?nlm_fbm
set.seed(100)
fbm_raster  <- nlm_fbm(ncol = 100, nrow = 100, fract_dim = 0.2)
################################################################################
# e)
# simulate random gaussian field
#?nlm_gaussianfield
set.seed(100)
gaussian_field <- nlm_gaussianfield(ncol = 100, nrow = 100,
autocorr_range = 100,
mag_var = 8,
nug = 5)
################################################################################
# g)
# simulate neighborhood model
set.seed(100)
neigh_raster <- nlm_neigh(ncol = 100, nrow = 100, p_neigh = 0.75, p_empty = 0.1,
categories = 5, neighbourhood = 8)
################################################################################
# h)
# simulate percolation model
set.seed(100)
percolation <- nlm_percolation(ncol = 100, nrow = 100, prob = 0.5)
# visualize the NLM
# landscapetools::show_landscape(percolation)
# plot(percolation)
################################################################################
# i)
# simulate planar gradient
set.seed(100)
planar_gradient <- nlm_planargradient(ncol = 100, nrow = 100)
################################################################################
# k)
# simulate polygonal landscapes
set.seed(100)
mosaictess <- nlm_mosaictess(ncol = 100, nrow = 100, germs = 50)
################################################################################
# l)
# simulate spatially random model
set.seed(100)
random <- nlm_random(ncol = 100, nrow = 100)
################################################################################
# m)
# simulate random clustering
set.seed(100)
random_cluster <- nlm_randomcluster(ncol = 100, nrow = 100,
p = 0.4,
ai = c(0.25, 0.25, 0.5))
# midpoint_displacement <- nlm_mpd(ncol = 102,
#                                  nrow = 102,
#                                  roughness = 0.7)
#
# # visualize the NLM
# landscapetools::show_landscape(midpoint_displacement)
# midpoint_displacement
################################################################################
# o)
# simulate random rectangular cluster
set.seed(100)
randomrectangular_cluster <- nlm_randomrectangularcluster(ncol = 100,
nrow = 100,
minl = 5,
maxl = 10)
################################################################################
# create predictor stack
# Random noise
rnoise <- raster(ncols=dimgrid, nrows=dimgrid, xmn=0, xmx=dimgrid, ymn=0, ymx=dimgrid)
# Defining stack of predictors
predictors <- stack(distance_gradient, edge_gradient, fbm_raster,
gaussian_field, mosaictess, neigh_raster,
planar_gradient, random, random_cluster,
randomrectangular_cluster)
plot(predictors9
plot(predictors)
plot(predictors)
train_points
# Extract information from stack in a data frame on the sample points
extr <- as.data.frame(raster::extract(all_stack, sampling_points()))
# Extract information from stack in a data frame on the sample points
extr <- as.data.frame(raster::extract(predictors, sampling_points()))
# Extract information from stack in a data frame on the sample points
extr <- as.data.frame(raster::extract(predictors, train_points))
extr
View(train_points)
train_point$geom
train_points$geom
train_points$geom$lat
train_points$geom$lon
train_points$geom.lon
train_points$geom$names
train_points$geom
extr$geom <- train_points$geom
extr
head(extr)
runApp('Test_shiny.R')
# Extract information from stack in a data frame on the sample points
extr <- as.data.frame(raster::extract(predictors, train_points))
head(extr)
extr$geom <- train_points$geom
head(extr)
runApp('Test_shiny.R')
?CreateSpacetimeFolds
spatial_blocks
?extract
runApp('Test_shiny.R')
generate_random_function <- function(raster_stack) {
# All possible operands (easy to extend the list)
operands = c("+", "-", "*", "^2 +", "^3 -", "^2 *", "^2 -", "^3 +")
expression = ""
for (i in 1:(nlayers(raster_stack)-1)){ # (-1 so that the last argument of the stack does not have an operand attached to it)
expression <- paste(expression, paste(as.character(substitute(raster_stack)), "$", names(raster_stack)[i], sep=""), sep = " ")
expression <- paste(expression, sample(operands, 1), sep = " ")
}
expression <- paste(expression, paste(as.character(substitute(raster_stack)), "$", names(raster_stack)[nlayers(raster_stack)], sep=""), sep = " ")
return(expression)
}
expr <- generate_random_function(predictors)
expr
train_points
runApp('Test_shiny.R')
runApp('Test_shiny.R')
runApp('Test_shiny.R')
